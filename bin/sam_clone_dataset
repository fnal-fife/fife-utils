#!/usr/bin/env python

try:
  import hashlib 
except:
  import md5
  class hashlib:
     pass
  hashlib.md5 = md5.md5

from fife_sam_utils import *
import sys
import os
from samweb_client import *
import socket
import optparse


def check_destination(samweb,dest):
    # /pnfs is officially okay
    if dest.find('/pnfs/') == 0:
        return 1
    # or any known data disk..
    for d in samweb.listDataDisks():
        p = re.sub('^\w+:','', d["mount_point"])
        if dest.find(p) == 0:
            return 1
    # otherwise, nope.
    return 0

def zerodeep(f):
    return '/'

def onedeep(f):
    h = hashlib.md5(f).hexdigest()
    return "/%s/" % h[0:4]

def twodeep(f):
    h = hashlib.md5(f).hexdigest()
    return "/%s/%s/" % (h[0:4], h[4:8])

notmade = {}
def dodir(ih, dir):
    
    if dir.startswith("/pnfs/") or dir.startswith("/%s/"%os.environ.get('EXPERIMENT','')):
        # we think globus-url-copy with -cd will make these, so we're done
        return

    for d in (dirname(dir), dir):
        if notmade.get(d,True):
           notmade[d] = False
           try:
               print "doing mkdir " , d
               ih.mkdir(d, '')
           except:
               pass

def already_there( f, loclist, dest ):
    res = False
    dest = dest + '/'
    for p in loclist:
	if p.find(dest) != -1:
	    print "Notice: file %s already has a copy at %s, skipping" % ( f, p)
	    res = True
            break
    return res

def copy_and_declare(d, cpargs, locargs, dest, subdirf, samweb, just_say, verbose):
    res = 0

    if len(cpargs) == 0:
        # nothing to do!
        return res

    # trailing ; confuses ifdh cp
    if cpargs[-1] == ';':
        cpargs = cpargs[:-1]

    if just_say:
	print "I would 'ifdh cp %s'" % cpargs
	for f in locargs:
	    print "I would declare location for %s of %s" % (f, dest+subdirf(f))
    else: 
        if verbose: print "doing ifdh cp %s" % cpargs
	res = d.ifdh_handle.cp(cpargs)
        if verbose: print "ifdh cp returns %d" % res
        # XXX note this is arguably incorrect, we only declare locations if
        #     *all* the copies in the batch succeed; but if *some* of them
        #     do we don't...
	if res == 0:
	    if verbose: print "doing locargs: ", locargs
	    for f in locargs:
                try:
                    loc =  samprefix(dest) + dest + subdirf(f)
                    if verbose: print "addFileLocation(%s, %s)" % (f, loc)
		    samweb.addFileLocation(f, loc )
                except:
                    raise
                    res = 1
    return res

def clone( d, dest, subdirf = twodeep, just_say=False, batch_size = 20, verbose = False, experiment = None ):
    # make gridftp tool add directories
    os.environ['IFDH_GRIDFTP_EXTRA'] = '-cd -sync'
    cpargs = []
    locargs = []
    count = 0
    samweb = SAMWebClient()

    if not check_destination(samweb,dest):
        print "Destination: %s is not known to SAM" % dest;
        print "...maybe you wanted ifdh_fetch?"
        return 0

    if experiment:
        samweb.experiment = experiment

    for f in d.file_iterator():

        loclist = samweb.getFileAccessUrls(f, schema = "gsiftp")

        if already_there(f, loclist, dest):
            continue
                
        if len(loclist) > 0:
            locargs.append(f)
            cpargs.append(loclist[0])
	    cpargs.append(dest + subdirf(f) + f)
            cpargs.append(';')
            dodir(d.ifdh_handle, dest+subdirf(f))
        else:
            print "Notice: skipping file %s, no locations" % f

        count = count + 1
        if count % batch_size == 0:

	    # above loop leaves a trailng ';', which confuses things.
            copy_and_declare(d, cpargs, locargs, dest, subdirf, samweb, just_say, verbose)
            cpargs = []
            locargs = []

    copy_and_declare(d, cpargs, locargs, dest, subdirf, samweb, just_say, verbose)


if __name__ == '__main__':

    parser = optparse.OptionParser(usage="usage: %prog [options] \n copy files in named dataset to destination and declare")
    parser.add_option('-v','--verbose',   action='count')
    parser.add_option('-j','--just_say',  action='store_false', help="do not actually copy, just say what you would do")
    parser.add_option('-e','--experiment')
    parser.add_option('-b','--batch_size',default = 20, type='int', help="copy then declare in batches of this size")
    parser.set_defaults(dirfunc = twodeep)
    parser.add_option('-0','--zerodeep',  dest='dirfunc', action='store_const', const=zerodeep, help="make no subdirectories in destination")
    parser.add_option('-1','--onedeep',   dest='dirfunc', action='store_const', const=onedeep, help = "make subdirectories one deep in destination")
    parser.add_option('-2','--twodeep',   dest='dirfunc', action='store_const', const=twodeep, help = "make subdirectories two deep in destination")
    parser.add_option('-n', '--name',     help="dataset name to copy", )
    parser.add_option('-d', '--dest',     help="destination for copy", )

    (o,a) = parser.parse_args()

    if o.experiment:
        os.environ['EXPERIMENT']= o.experiment
        os.environ['IFDH_BASE_URI'] = "http://samweb.fnal.gov:8480/sam/%s/api" % o.experiment

    if not o.name:
        parser.error("expected --name dataset-name")
        exit(1)

    if not o.dest:
        parser.error("expected --dest url")
        exit(1)

    clone(dataset(o.name), o.dest, subdirf = o.dirfunc, just_say = o.just_say, batch_size = o.batch_size, verbose = o.verbose, experiment=o.experiment)
