#!/usr/bin/env python

try:
   from six import  *
except:
   pass

try:
    import configparser
except:
    import ConfigParser as configparser

import traceback
import sys
import os
import optparse
try:
    import urllib.parse, urllib.error
    def urllib_quote(x):
        return urllib.parse.quote(x)
except:
    import urllib
    def urllib_quote(x):
        return urllib.quote(x)

import shutil
from samweb_client import *
try:
    import poms_client
except:
    pass

def check_exp_err(k, v1, v):
    if v1 and not v:
        raise KeyError("Error: expanding:\n %s: %s \n error in expansion!")

class launcher(object):
 
    def __init__(self, cfgfilename, overrides, jobname = None, stages = [], fake=None, config_dump = None , arg_push = [], arg_del = []):
        self.cfg = configparser.SafeConfigParser()
        self.stages = stages
        self.cfg.optionxform = str
        self.is_boolean_flag = {}
        self.included = {}
        self.fake = fake
        self.jobname = jobname
        self.searchpath = os.environ.get("FIFE_LAUNCH_PATH","").split(":")
        self.nfiles_in_dataset = None
 
        if cfgfilename == None:
             sys.stderr.write("Error: missing required -c configfile option\n")
             sys.exit(1)
        # now pull in the config file with includes
        self.do_cfg_includes(cfgfilename)

        if config_dump == 'before' or config_dump == 'both':
           sys.stderr.write("config before expansion:\n================\n")
           self.cfg.write(sys.stderr)
           sys.stderr.write("\n================\n")

        # handle stage overrides up front
        for stage in stages:
            stagetag = 'stage_' + stage
            if self.cfg.has_section(stagetag):
                for k,v in self.cfg_items(stagetag, raw=1):
                    s,n = k.split('.',1)
                    self.cfg.set(s,n,v)
               
        # then command line overrides last
        if overrides:
            for o in overrides:
                #print "o is", o
                try:
                    k, v = o.split('=',1)
                    s,n = k.split('.',1)
                except:
                    sys.stderr.write("Error: cannot parse '-O%s'\n" % o)
                    sys.stderr.write("   --  expected -Osection.key=value\n")
                    sys.exit(1)

                try:
                    self.cfg.set(s,n,v)
                except:
                    sys.stderr.write("Error: cannot store '-O%s'\n" % o)
                    sys.stderr.write("   --  no such section in configuration?\n")
                    sys.exit(1)

        # arg push/parse replace...
        # - put them in an args list
        # - shuffle as requested
        # - stick back in arg_n config entries
        args = []
        for i in range(1,30):
            try:
                v = self.cfg_get('executable','arg_%d'%i, raw=True)
            except:
                v = None
            if v != None:
                args.append(v)

        for v in arg_push:
            args.insert(0,v)

        for v in arg_del:
            args.remove(v)

        for i in range(1,30):
            if i <= len(args):
                self.cfg.set('executable', 'arg_%d' % i, args[i-1])
            else:
                try:
                    self.cfg.remove_option('executable', 'arg_%d' % i)
                except:
                    break

        if config_dump == 'after' or config_dump == 'both':
           sys.stderr.write("config after expansion:\n================\n")
           self.cfg.write(sys.stderr)
           sys.stderr.write("\n================\n")

        self.get_fife_wrap_booleans()

        self.cfg_globals = dict(self.cfg.items('global'))

    def get_fife_wrap_booleans(self):
        f = os.popen("%s/libexec/fife_wrap --help" % os.environ.get("FIFE_UTILS_DIR",os.path.dirname(os.path.dirname(sys.argv[0]))))
        for l in f:
            p1 = l.find("--")
            if p1 >= 0:
                # we have a --option
                p2 = l.find(" ",p1)
                p3 = l.find("=",p1)
                if p3 > 0:
                    # ...--name=value line
                    name=l[p1+2:p3]
                    self.is_boolean_flag[name] = False
                else:
                    # ...--name line (no value)
                    name=l[p1+2:p2]
                    self.is_boolean_flag[name] = True
        f.close()
     
    def cfg_get(self, section, name, vars={}):
        ''' like cfg.get() except it gives None and not an exception '''
        try:
            res = self.cfg.get(section, name, vars=vars)
        except:
            res = None
        return res

    def cfg_items(self, section, raw = None):
        ''' like cfg.items() except it gives [] and not an exception '''
        try:
            res = self.cfg.items(section, raw = raw)
        except:
            res = []
        return res

    def do_cfg_includes(self, cffile):
        #print "do_cfg_includes:" , cffile
        found = False
        for d in ['.', '' ] + self.searchpath:
            if os.path.exists("%s/%s" % (d,cffile)):
                cffile = "%s/%s" % (d,cffile)
                found = True
                break

        if not found:
             sys.stderr.write("Error: -c configfile '%s' not found.\n" % cffile)
             sys.exit(1)
             
        if self.included.get(cffile, None):
            return
        self.included[cffile] = 1
        self.cfg.read(cffile)
        if self.cfg.has_option('global','includes'):
            cfls = self.cfg_get('global', 'includes')
            for cf in cfls.split(" "): 
                if cf: 
                     self.do_cfg_includes(cf)

    def pre_launch(self, dry_run = False):
        for i in range(10):
            if i > 0: 
                suffix="_%d" % i
            else:
                suffix=""

            dest = self.cfg_get('job_output'+suffix,'dest', vars= self.cfg_globals)
            uniqflag = self.cfg_get('job_output'+suffix,'dest_uniq_rename', vars= self.cfg_globals)

            ## do mkdir with the right experiment set...
            exp = self.cfg_get('env_pass','SAM_EXPERIMENT', vars= self.cfg_globals)
            if exp and not os.environ.get('EXPERIMENT', None):
                os.environ['EXPERIMENT'] = exp

            if dest and not uniqflag and not dest.find('$') >= 0:
                if dry_run:
                    print("I would: ifdh mkdir_p %s" % dest)
                else:
                    import ifdh
                    ih = ifdh.ifdh()
                    ih.mkdir_p(dest)

        dataset = self.cfg_get('submit','dataset',vars = self.cfg_globals)
        if dataset:
            if dry_run:
                print("I would: samweb count_definition_files %s" % dataset)
                print("and make sure its non-zero...")
            else:
                experiment = self.cfg_get('submit','G', vars = self.cfg_globals)
                samweb = SAMWebClient(experiment = experiment)
                self.nfiles_in_dataset = samweb.countFiles(defname = dataset)
                if self.nfiles_in_dataset  == 0:
                     print("Ignoring launch request on empty dataset")
                     sys.exit(1)

    def launch(self, dry_run = False):
        if dry_run:
            print("Pre-launch checks:")
            self.pre_launch(dry_run = True)
            # trim down to command and args from jobsub line
            cmd = self.build_launch()
            print("Then I would run: \n-----\n%s\n-----" % cmd)
            print("... which would, in the job, do:\n-----")
            cmd = cmd[cmd.find("file://")+8:]
            cmd = cmd.replace(" "," --dry_run ",1)
            os.system(cmd)
            print("-----")
        else:
            self.pre_launch()
            print(( "running:\n %s" , cmd))
            cmd = self.build_launch()
            os.system(cmd)

        if self.jobname != None:
            os.unlink(self.jobwrapfile)

    def build_launch(self):
        res = []

        res.append("set -x")

        #
        # if we are doing our own POMS stuff, hide poms_jobsub_wrapper's 
        # version of jobsub_submit, by pushing jobsub_client's bin
        # back on the front of the path.
        #
        if self.cfg.has_section("poms_get_task_id"):
            res.append( "PATH=$JOBSUB_CLIENT_DIR:$PATH")

        res.append( "GROUP=%s; export GROUP" % self.cfg_get('global','group', vars = self.cfg_globals))

        #for k,v in self.cfg_items("env_pass", raw = 1):
        #    v = self.cfg_get("env_pass",k,vars = self.cfg_globals)
        #    res.append("%s='%s'; export %s" % (k, v, k))

        if self.cfg.has_section("submit"):

            nfpj = self.cfg_get("submit","n_files_per_job",vars = self.cfg_globals)
            if nfpj and int(nfpj) > 0:
                # we already counted the dataset files in pre_launch, 
                # so just compute 
                if self.nfiles_in_dataset != None:
                    self.cfg.set("submit","N",str(self.nfiles_in_dataset/int(nfpj)))

                else:
                    sys.stderr.write("Error in config [submit]: n_jobs_per_file requires dataset\n")
                    sys.exit(1)
                        

            if self.fake:
                res.append("fake_jobsub \\")
            else:
                res.append("jobsub_submit \\")

            for k,v1 in self.cfg_items("env_pass", raw = 1):
                v = self.cfg_get("env_pass",k,vars = self.cfg_globals)
                check_exp_err(k, v1, v)
                res.append( "  -e %s='%s' \\" % (k,v) )

            if self.cfg.has_section("poms_campaign_layer"):
                #
                # do the full poms_client game:
                # -- register the campaign
                # -- request a task_id
                #
                campaign_kwargs = {}
                for k,v1 in self.cfg_items("poms_campaign_layer", raw = 1):
                     v = self.cfg_get("poms_campaign_layer",k,vars = self.cfg_globals)
                     check_exp_err(k, v1, v)
                     campaign_kwargs[k] = v

                campaign_id = poms_client.register_poms_campaign(**campaign_kwargs)
                poms_get_id_kwargs = {'campaign': campaign_id }
            else:
                poms_get_id_kwargs = {}
                

            for k,v1 in self.cfg_items("submit", raw = 1):
                if k == "n_files_per_job":
                   continue
                v = self.cfg_get("submit",k,vars = self.cfg_globals)
                check_exp_err(k, v1, v)
                if len(k) > 2 and k[-2] == '_' and k[-1] in "0123456789":
                     k = k[:-2]
                if len(k) == 1:
                    res.append("  -%s '%s'  \\" %( k,v))
                elif v == 'True' or v == True:
                    res.append("  --%s \\" % k)
                else:
                    res.append("  --%s='%s'  \\" %( k,v))

            wrapfile = os.path.expandvars(self.cfg_get('global','wrapper',vars = self.cfg_globals))
            if wrapfile.startswith("file:///"):
                wrapfile=wrapfile[7:]

            if not self.jobname and self.cfg_get('global','jobname'):
                self.jobname = self.cfg_get('global','jobname')

            if self.jobname != None:
                self.jobwrapfile = "/tmp/%s_%d" % (self.jobname, os.getpid())
                print("DEBUG: copying %s to %s " %( wrapfile, self.jobwrapfile))
                shutil.copy(wrapfile, self.jobwrapfile)
            else:  
                self.jobwrapfile = wrapfile

            res.append("  file:///%s \\" % self.jobwrapfile)

            for k,v1 in self.cfg_items("job_setup", raw=1):
                v = self.cfg_get("job_setup",k,vars = self.cfg_globals)
                check_exp_err(k, v1, v)
                if len(k) > 2 and k[-2] == '_' and k[-1] in "0123456789":
                     k = k[:-2]
                if self.is_boolean_flag[k]:
                    if v == 'True' or v == True:
                        res.append("    --%s \\" % k)   
                else:
                    if k in ['export','source','setup','prescript','postscript'] and v and urllib_quote(v) != v:
                         k = '%s-unquote' % k
                         v = urllib_quote(v)
                    res.append("    --%s '%s' \\" % (k,v))   

   
            for k,v1 in self.cfg_items("sam_consumer", raw=1):
                v = self.cfg_get("sam_consumer",k,vars = self.cfg_globals)
                check_exp_err(k, v1, v)
                if self.is_boolean_flag[k]:
                    if v == 'True' or v == True:
                        res.append("  --%s \\" % k)
                else:
                    res.append("    --%s '%s' \\" % (k,v))   

            for i in range(10):
                if i == 0:
                    ssuffix=""
                    osuffix=""
                else:
                    ssuffix="_%d" % i
                    osuffix="%d" % i

                if not self.cfg.has_section("job_output"+ssuffix):
                    break

              
                for k,v1 in self.cfg_items("job_output"+ssuffix, raw=1):
                    v = self.cfg_get("job_output"+ssuffix,k,vars = self.cfg_globals)
                    check_exp_err(k, v1, v)
 
                    if self.is_boolean_flag[k]:
                        if  v == 'True' or v == True:
                            res.append("    --%s%s \\" % (k,osuffix))   
                    else:
                        if k in ['metadata_extractor'] and v and urllib_quote(v) != v:
                            k = '%s_unquote' % k
                            v = urllib_quote(v)
                        res.append("    --%s%s '%s' \\" % (k,osuffix, v))

            for i in range(9):
                if i == 0:
                    sname = "executable"
                else:
                    sname = "executable_%d" % i

                if not self.cfg.has_section(sname):
                    continue

                res.append("  --exe  %s \\" % self.cfg_get(sname,'name', vars = self.cfg_globals))
                if self.cfg_get(sname,'exe_stdout'):
                    res.append("  --exe_stdout%d %s \\" % (i, self.cfg_get(sname,'exe_stdout', vars = self.cfg_globals)))

                if self.cfg_get(sname,'exe_stderr'):
                    res.append("  --exe_stderr%d %s \\" % (i, self.cfg_get(sname,'exe_stderr', vars = self.cfg_globals)))

            for i in range(9):
                if i == 0:
                    sname = "executable"
                else:
                    sname = "executable_%d" % i

                if not self.cfg.has_section(sname):
                    continue

                res.append(" -- \\") # end options to wrapper

                for k,v1 in self.cfg_items(sname, raw=1):
                    v = self.cfg_get(sname,k,vars = self.cfg_globals)
                    check_exp_err(k, v1, v)
                    if k.startswith('arg_'):
                        res.append("      %s \\" % v)

            if self.cfg.has_section("poms_get_task_id"):

                if os.environ.get("POMS_TEST","") != "":
                    poms_get_id_kwargs['test'] = os.environ["POMS_TEST"]

                if os.environ.get("POMS_PARENT_TASK_ID","") != "":
                    poms_get_id_kwargs['parent_task_id'] = os.environ["POMS_PARENT_TASK_ID"]
                poms_get_id_kwargs['command_executed'] = '\n'.join(res)

                for k,v1 in self.cfg_items("poms_get_task_id", raw = 1):
                    v = self.cfg_get("poms_get_task_id",k,vars = self.cfg_globals)
                    check_exp_err(k, v1, v)
                    poms_get_id_kwargs[k] = v

                #
                # looks redundant, allows override from config file
                # or value from register_poms_campaign
                #
                campaign_id = poms_get_id_kwargs['campaign']

                task_id = poms_client.get_task_id_for(**poms_get_id_kwargs)

                n = res.index("jobsub_submit \\") + 1
                
                res.insert(n,' -e POMS_CAMPAIGN_ID=%s \\' % campaign_id)
                res.insert(n,' -e POMS_TASK_ID=%s \\' % task_id)
                res.insert(n,''' -l "+FIFE_CATEGORIES='\\"POMS_TASK_ID_%s,POMS_CAMPAIGN_ID_%s,%s\\"'"  \\''' % (
                        task_id, campaign_id, os.environ.get("POMS_CAMPAIGN_TAGS","")
                   ))
                res.insert(n,' -l "+POMS_TASK_ID=%s"  \\' % task_id)
                res.insert(n,' -l "+POMS_CAMPAIGN_ID=%s"  \\' % campaign_id)

            res.append("")


        elif self.cfg.has_section("submit_dag"):
            # XXX not doing dags -- yet
            print("submit_dag not yet implemented...")
            pass
        else:
            raise KeyError("Need [submit] or [submit_dag] sections...")


        return "\n".join(res)

if __name__ == '__main__':
    p = optparse.OptionParser(description='launch a job with parameters'
,
                            prog='fife_launch',
                            version='1.1',
                            usage='%prog --config file.cfg --override foo.bar=10')


    p.add_option('-c', '--config', help='config file describing job')
    p.add_option('-O', '--override',  help='override config file values', action='append' )
    p.add_option('--jobname', help='job name for launching', default=None)
    p.add_option('--stage', action='append', help='stage name to add options from', default=[])
    p.add_option('--fake', action='store_true', help='use fake_jobsub', default=None)
    p.add_option('--dry_run', action='store_true', help='Just print what we would do', default=None)
    p.add_option('--config_dump', help='dump our config "before" or "after" expansion and overrides (or "both")', default=None)
    p.add_option('--arg_push', action='append', help='push a command line argument in the executable section', default=[])
    p.add_option('--arg_del', action='append', help='delete a specific argument in the executable section', default=[])
    options, args = p.parse_args()
   
    try:
        l = launcher(options.config, options.override, options.jobname, options.stage, options.fake, options.config_dump, options.arg_push, options.arg_del)
        # evaluate some things to make sure we have them...
        l.cfg.items('global',raw=1)
        l.cfg.items('submit',raw=1)
        l.cfg.items('executable',raw=1)
    except configparser.Error as e:
        sys.stderr.write("Error in config file(s): %s\n" % e)
        raise
        sys.exit(1)
    except Exception as e:
        sys.stderr.write("Error in setup: %s\n" % e)
        traceback.print_exc()
        sys.exit(1)

    l.launch(options.dry_run)
