#!/usr/bin/env python

import os
import sys
import time
import subprocess
import signal
import grp
import urllib
import glob

class Wrapper:
    def __init__(self):
        self.experiment = os.environ.get('EXPERIMENT',os.environ.get('SAM_EXPERIMENT',os.environ.get('GROUP',grp.getgrgid(os.getgid())[0])))
        self.setupslist = [
            '/cvmfs/%s.opensciencegrid.org/externals/setups' % self.experiment,
            '/cvmfs/oasis.opensciencegrid.org/%s/externals/setups' % self.experiment,
            '/grid/fermiapp/products/%s/externals/setups' % self.experiment,
            '/cvmfs/fermilab.opensciencegrid.org/products/common/etc/setups',
            '/grid/fermiapp/products/common/etc/setups',
        ]
        os.setpgrp()
        self.ih = None
        self.cpurl = None
        self.consumerid = None
        self.timeoutproc = None
        self.rres = 0

    def start_self_destruct(self):
        if self.options.self_destruct_timer == None:
             print "no self destruct..."
             return
        timeout = self.options.self_destruct_timer 
        watchpid=os.getpid()
        rate=10
        sofar = 0
        start = time.time()
        res = os.fork()
        if 0 == res:
            try:
               while sofar < timeout:
                   os.kill(watchpid, 0)
                   time.sleep(rate)
                   sofar = time.time() - start
            except OSError:
               # should be kill failing as parent exited already
               exit(0)
            # we timed out, start shooting things
            signal.signal(15,signal.SIG_IGN) # ... except us
            os.killpg(watchpid,15)
            time.sleep(10)
            os.killpg(watchpid,9)
            exit(0)
        elif res > 0:
            # we forked a job, make a note
            self.timeoutproc = res
        else:
            print "Unable to fork timeout process, something is probably wrong"
        return

    def parse_arguments(self):
        import optparse
        parser = optparse.OptionParser()
    
	parser.add_option("-q","--quals", help="Set qualifiers for ifdh_art setup")
	parser.add_option("-v","--vers", help="Set version for ifdh_art setup")
	parser.add_option("-c","--config", help="Specify config file (fcl) for art executable")
	parser.add_option("-X","--exe", help="Specify executable name for art executable -- default $EXPERIMENT")
	parser.add_option("-D","--dest", help="Specify destination for copyBackOutput")
	parser.add_option("-R","--rename", action="append", dest="rename", help="Specify output file rename after Art runs")
	parser.add_option("--rename2", action="append", dest="rename")
	parser.add_option("--rename3", action="append", dest="rename")
	parser.add_option("-g","--getconfig", action="store_true", help="get config files as inputs from SAM (i.e. for MonteCarlo simulation). Conflicts with --config")
	parser.add_option("--confbase", help="Base fcl file to prepend to fetched ones if running --getconfig")
	parser.add_option("-M","--multifile", action="store_true", help="Fetch files in wrapper and run executable once per file")
	parser.add_option("-G","--with_gdb", action="store_true", help="run executable under gdb and print stack trace")
	parser.add_option("-L","--limit", type="int", help="Set SAM project file delivery limit", default=0)
	parser.add_option("-I","--inputfile", action="append", help="Input file to copy to job area before running the executable")
	parser.add_option("-T","--inputtar", action="append", help="Input tar file to copy to job area and unpack running the executable")
	parser.add_option("--inputlist", action="append", help="ifdh cp -f file to run to fetch inputs")
	parser.add_option("--outputlist", action="append", help="ifdh cp -f file to run to copy out outputs")
	parser.add_option("-O","--addoutput",action="append",  help="glob pattern to match and call addOutputFile on")
	parser.add_option("--export",action="append",  help="export environment variable before running", default= [])
	parser.add_option("--export-unquote",action="append",  help="export environment variable before running", default= [])
	parser.add_option("--setup",action="append",  help="setup product before running", default=[])
	parser.add_option("--source",action="append",  help="source setup file before running", default = [])
	parser.add_option("--self_destruct_timer", type="int", help="After this many seconds, suicide the job so we get output back")
	parser.add_option("--prescript", help="script to run before Art executable")
	parser.add_option("--postscript", help="script to run after Art executable")
	parser.add_option("--debug", action="count", help="Turn on debugging")
	parser.add_option("--ifdh_art", action="store_true", help="executable can run the ifdh_art getNextFile loop ")
         
        parser.add_option("--appname", help="application name for SAM", default="demo")
        parser.add_option("--appfamily", help="application family for SAM", default="demo")
        parser.add_option("--appvers", help="application version for SAM", default=os.environ.get("ART_VERSION","1"))
        parser.add_option("--userscript", action="append", help="extra user script to run after main executable" )
	parser.add_option("--find_setups", action="store_true", help="look in the 'usual places' for the ups setups script at startup")
	parser.add_option("--start_project_on", default=None, help="start a sam project on this dataset ")
	parser.add_option("--end_project", action="store_true", help="look in the 'usual places' for the ups setups script at startup")
	parser.add_option("--nosetup", action="store_true", help="do not run setup actions (used internally)")

	(self.options, self.args) = parser.parse_args()
        print "Options: ", self.options
        print "Args: ", self.args

    def do_setup(self):
        #
        # run export and source stuff in a shell
        # and slurp the resulting environment back in.
        #

        if self.options.nosetup:
             print "running with nosetup"
             try:
                 import ifdh
                 print "imported ifdh"
             except:
                 pass
             return

        scriptlist = ['set -x\n']

        if self.options.find_setups:
            scriptlist.append("for p in %s ; do if [ -r $p ]; then . $p; break; fi; done" % ' '.join(self.setupslist))

        if self.options.export:
            for e in self.options.export:
                scriptlist.append("export %s" % e)

        if self.options.export_unquote:
            for e in self.options.export_unquote:
                scriptlist.append("export %s" % urllib.unquote(e))

        if self.options.source:
            for s in self.options.source:
                scriptlist.append("source %s" % s)

        if self.options.setup:
            for s in self.options.setup:
                scriptlist.append("setup %s" % s)

        scriptlist.append('[ -z "$IFDHC_DIR" ] || setup ifdhc')

        cuthere="--------------cut here-------------"
        scriptlist.append("""
echo
echo "%s"
cat <<'EOF' | python
import os
import re
for v in os.environ.keys():
    if v.find('()') > 0:
        continue
    fix= re.sub( "\'", "\\'", os.environ[v])
    print "os.environ['"+v+"'] = '" + fix + "'" 
EOF
exit
""" % cuthere )
        p = subprocess.Popen("/bin/bash" , stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        p.stdin.write("\n".join(scriptlist))
        found = False
        evallist = []
        for l in p.stdout.readlines():
             print "read: " , l
             if found:
                 print "appending"
                 evallist.append(l)
             if l.rstrip() == cuthere:
                 print "found cut here"
                 found = True
        p.stdin.close()
        p.stdout.close()
        exec ''.join(evallist)
        # just assume the setup stuff made a different python environment(?)
        sys.argv = [ 'python' , sys.argv[0] , '--nosetup' ] + sys.argv[1:]
        print "about to exec, args: ", sys.argv
        os.execvpe( 'python', sys.argv, os.environ)
        raise(Exception("Could not restart under new python"))

    def start_client(self):
        print "entering start_client"
        import ifdh
        import socket

        hostname = socket.getfqdn()

        if os.environ.has_key('JOBSUBJOBID'):
            description = os.environ['JOBSUBJOBID']
        elif os.environ.has_key('CLUSTER'):
            description = "%s.%s" %(os.environ['CLUSTER'],os.environ('PROCESS'))
        else:
            description = "process %d on %s" % (os.getpid(), hostname)

        if self.ih == None:
            self.ih = ifdh.ifdh()

        # assume SAM_PROJECT and SAM_STATION are set...
        if self.cpurl == None:
            self.cpurl = self.ih.findProject(os.environ['SAM_PROJECT'],os.environ.get('SAM_STATION', os.environ.get('EXPERIMENT','')))
        self.consumerid=None

        for i in range(0,1):
            try:
                print "trying to establish consumer process"
                self.consumerid = self.ih.establishProcess( 
		   self.cpurl, 
		   self.options.appname, 
		   self.options.appvers, 
                   hostname,
                   os.environ.get('GRID_USER',os.environ.get('USER')),
		   self.options.appfamily,
		   description,
		   self.options.limit,
                   ""
                )
                print "Got consumerid of: " , self.consumerid

            except Exception as e:
                print "Got exception: ", e

            if self.consumerid:
                break

    def file_loop(self):
        print "Entering file loop:"
        self.rres = 0

        if self.options.multifile or self.options.getconfig:
            furi=self.ih.getNextFile(self.cpurl,self.consumerid)
	    while furi:
                # do not unneccesarily go through bestman...
                if furi.startswith("gsiftp://fg-bestman1.fnal.gov:2811"):
                    uri = "file://" + furi[34:]
                    print "de-bestman-ified path: ", furi
                fname=self.ih.fetchInput(furi)
                print "Fetching: %s gave: %s" % (furi, fname)
                self.ih.updateFileStatus(self.cpurl, self.consumerid, fname, 'transferred')
		cmdlist = [ self.options.exe ]
		if self.options.getconfig:
		    cmdlist.append('-c')
		    cmdlist.append(fname)
		    cmdlist.extend(self.args)
		else:
		    cmdlist.append('-c')
		    cmdlist.append(self.options.config)
		    cmdlist.extend(self.args)
		    cmdlist.append(fname)

		if self.options.with_gdb:
		    f = open('.gdbcmds')
		    f.write('run\nwhere\nquit\n')
		    cmdlist = ['gdb', '-x', '.gdbcmds', '--args' ] + cmdlist

                cmd = " ".join(cmdlist)
                print "Running: ", cmd
		res = os.system(cmd)
		if 0 == res:
                    print "Success, marking consumed"
		    self.ih.updateFileStatus(self.cpurl, self.consumerid, fname, 'consumed')
		else:
                    print "Failed, marking skipped"
		    self.ih.updateFileStatus(self.cpurl, self.consumerid, fname, 'skipped')
		    self.rres = res
		furi=self.ih.getNextFile(self.cpurl,self.consumerid)

	elif self.options.ifdh_art:

            # file loop is actually in the art executable
	    # so we have to pass options in to it to
            # invoke the loop

	    cmdlist = [ self.options.exe ]
	    cmdlist.append('-c')
	    cmdlist.append(self.options.config)
	    cmdlist.append("--sam-web-uri=%s" % self.cpurl)
	    cmdlist.append("--sam-process-id=%s" % self.consumerid)
	    cmdlist.extend(self.args)

	    if self.options.with_gdb:
		 f = open('.gdbcmds')
		 f.write('run\nwhere\nquit\n')
		 cmdlist = ['gdb', '-x', '.gdbcmds', '--args' ] + cmdlist

	    res = os.system(" ".join(cmdlist))
	    self.rres = res

	else: 
            # just run the exe..
	    cmdlist = [ self.options.exe ]
	    cmdlist.extend(self.args)
	    if self.options.with_gdb:
		 f = open('.gdbcmds')
		 f.write('run\nwhere\nquit\n')
		 cmdlist = ['gdb', '-x', '.gdbcmds', '--args' ] + cmdlist
	    res = os.system(" ".join(cmdlist))
	    self.rres = res

        print "leaving file loop:"

    def fetch_inputs(self):
        # first copy any tarfiles,inputlists, and outputlists here
        cplist = ['-D']
        if self.options.inputtar == None:
            self.options.inputtar = []
        if self.options.inputfile == None:
            self.options.inputfile= []
        if self.options.inputlist == None:
            self.options.inputlist= []
        if self.options.outputlist == None:
            self.options.outputlist= []
        for it in self.options.inputfile + self.options.inputtar + self.options.inputlist + self.options.outputlist:
            cplist.append(it)
        cplist.append('.')
        if len(cplist) > 2:
           self.ih.cp(cplist)

        # then do the copies in any of the input lists
        cplist = []

        for it in self.options.inputlist:
            cplist.append('-f')
            cplist.append(it)
        if len(cplist) > 1:
           self.ih.cp(cplist)

        # and unpack any tarfiles
        for it in self.options.inputtar:
            if it.find('gz') > 0:
                os.system("tar xzvf %s" % it)
            else:
                os.system("tar xvf %s" % it)

    def userscripts(self):
        if not self.options.userscript:
            return
        for s in self.options.userscript:
            os.system(s)

    def copy_back(self):
        print "Entering copy_back:"

        if self.ih == None:
            try:
                import ifdh
            except:
                pass
            self.ih = ifdh.ifdh()

	if self.options.dest and self.options.addoutput:
	    for g in self.options.addoutput:
		for f in glob.glob(g):
		    self.ih.addOutputFile(f)

            if self.options.rename:
	        for r in self.options.rename:
		    self.ih.renameOutput(r)

	    self.ih.copyBackOutput(self.options.dest)

        # handle any touput file lists
        cplist = []
        if self.options.outputlist:
            for it in self.options.outputlist:
                cplist.append('-f')
                cplist.append(it)
        if len(cplist) > 1:
           self.ih.cp(cplist)
  
    def cleanup(self):
        print "Entering cleanup:"
        if self.ih and self.cpurl and self.consumerid:
	    self.ih.setStatus(self.cpurl, self.consumerid, "ok" if 0 == self.rres else "bad")
	    self.ih.cleanup()
        if self.timeoutproc:
            os.kill(self.timeoutproc)

    def start_project(self):
        if self.ih == None:
            self.ih = ifdh.ifdh()

        self.cpurl = self.ih.startProject(
		os.environ['SAM_PROJECT'],
		os.environ.get('SAM_STATION', 
		os.environ.get('EXPERIMENT','')), 
                self.start_project_on,
                os.environ.get('GRID_USER',os.environ.get('USER','unknown')),
		os.environ.get('EXPERIMENT',''))

    def end_project(self):
        if self.cpurl == None:
            self.cpurl = self.ih.findProject(os.environ['SAM_PROJECT'],os.environ.get('SAM_STATION', os.environ.get('EXPERIMENT','')))
        self.ih.endProject(self.cpurl)

# end Wrapper

if __name__ == '__main__' :
    print "Starting up..."
    w = Wrapper()
    try:
	w.parse_arguments()
	w.do_setup()
        if w.options.start_project_on:
             w.start_project()
	w.start_self_destruct()
        w.fetch_inputs()
        if w.options.ifdh_art or  w.options.multifile or w.options.getconfig:
	    w.start_client()
	w.file_loop()   
        w.userscripts()
	w.copy_back()
    except:
        raise
    finally:
        w.cleanup()

    try:
	if w.options.end_project:
	   w.end_project()
    except:
        pass

    exit(w.rres)
